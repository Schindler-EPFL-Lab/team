from typing import Optional

import numpy as np
from rws2.RWS_wrapper import RwsWrapper

from team.trajectory import Trajectory


class DemonstrationPlayer:
    """
    Plays demonstrated trajectories saved in the json format or the trajectory
    generated by the dynamical movement primitives approach.

    See 'recorder.py' for the recording procedure.

    :param base_url: url address to establish communication with
    :param tolerance_diff: discrepancy between consecutive robot joint angles targets
                           that is tolerated (unit: degrees)
    """

    def __init__(self, base_url: str, tolerance_diff: float = 1) -> None:
        self.current_pose: Optional[np.ndarray] = None
        self.next_target: Optional[np.ndarray] = None
        # control the smoothness of the reproduction (unit: degrees)
        self.tol_diff = tolerance_diff
        self.rws = RwsWrapper(robot_url=base_url)

    def is_target_eligible(self) -> bool:
        """
        Checks that the distance between the actual robot joint angles and the target
        joint angles is large enough. It avoids performing micro movements.

        :return: boolean assessing if the target needs to be considered or not
        """
        return self.compute_difference() > self.tol_diff

    def compute_difference(self) -> float:
        """
        Computes the norm between the two joint angles vectors.

        :return: the distance between the two vectors
        """
        assert self.next_target is not None
        distance = np.linalg.norm(self.next_target - self.current_pose)
        return distance

    def play(self, trajectory: Trajectory) -> None:
        """
        Firstly, it sends the robot to the initial trajectory joint angles. Then, if the
        new target is far enough, it executes the motion, otherwise it queries the
        next one. It repeats until the end of the trajectory and finally motors are
        turned off.

        :param trajectory: Trajectories object to reproduce
        """
        self.rws.set_RAPID_variable("program_running", "TRUE")
        for i, joints in enumerate(trajectory.joints):
            self.next_target = joints
            if i == 0:
                self.current_pose = joints
                self.execute_target(self.set_target())
            elif self.is_target_eligible():
                self.execute_target(self.set_target())
                self.current_pose = self.next_target
        self.rws.robot.motors_off()

    def set_target(self) -> str:
        """
        Creates the target in the required format accepted by RAPID.

        :return: string of a list of lists containing the joint positions (degrees) and
        the external axis
        """
        assert self.next_target is not None
        joint_list = self.next_target.tolist()
        ext_axis_list = [9e9, 9e9, 9e9, 9e9, 9e9, 9e9]
        target = str([joint_list, ext_axis_list])
        return target

    def execute_target(self, target) -> None:
        """
        Manipulates the RAPID variable (Joint) to set a new target and reach it.

        :param target: new target value to assign to the robot
        """
        self.rws.set_RAPID_variable("Joint", target)
        self.rws.complete_instruction()
